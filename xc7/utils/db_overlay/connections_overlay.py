from collections import namedtuple

from prjxray.connections import *

# =============================================================================


class ConnectionsWithExt(Connections):
    """
    This class allows to supply a superset of connection rules defined in
    tileconn.json The so called "extended" connections are generated first,
    then all the connections generated by the base class are yielded.
    """

    Loc  = namedtuple("Loc",  "x y")

    def __init__(self, tilegrid, tileconn, tileconn_ext, tile_wires):

        # Initialize base class
        Connections.__init__(self, tilegrid, tileconn, tile_wires)

        # Store the extended connections
        self.tileconn_ext    = tileconn_ext
        self.connections_ext = {}

        # Initialize extended connections
        self._init_connections_ext()

    def _init_connections_ext(self):

        # Build grid coordinates to tile name map
        self.grid_by_loc = {}
        for tile_name, tile in self.grid.items():
            tile_loc = self.Loc(tile["grid_x"], tile["grid_y"])
            self.grid_by_loc[tile_loc] = tile_name

        self.connections_ext = {}

        # Loop over the whole grid
        for tile_name, tile in self.grid.items():
            base_loc = self.Loc(tile["grid_x"], tile["grid_y"])

            # Check each connection rule for matching tile types at given
            # offsets.
            for rule in self.tileconn_ext:
                search_tile_types = rule["tile_types"]

                # Look up the grid for underlying tile types
                grid_tile_types  = []
                for grid_delta in rule["grid_deltas"]:
                    tile_loc = self.Loc(base_loc.x + grid_delta[0], base_loc.y + grid_delta[1])
                    try:
                        tile_name = self.grid_by_loc[tile_loc]
                        tile_type = self.grid[tile_name]["type"]
                        grid_tile_types.append(tile_type)
                    except KeyError:
                        grid_tile_types.append(None)

                # Check if we have a matching pattern
                if search_tile_types == grid_tile_types:

                    # Store the matching rule with location as a key
                    self.connections_ext[base_loc] = rule

    def get_connections(self):
        """
        This is a generator function which returns Connection objects for
        the whole FPGA grid.
        :return:
        """

        # Loop over all extended connection rules that have been matched
        for base_loc, rule in self.connections_ext.items():

            # Yield all connections for that rule
            for connection in rule["connections"]:
                indices = connection["indices"]

                # Get tile locations by adding grid deltas to the base location
                loc_a = self.Loc(base_loc.x + rule["grid_deltas"][indices[0]][0],
                                 base_loc.y + rule["grid_deltas"][indices[0]][1])
                loc_b = self.Loc(base_loc.x + rule["grid_deltas"][indices[1]][0],
                                 base_loc.y + rule["grid_deltas"][indices[1]][1])

                # Get tile names
                tile_a = self.grid_by_loc[loc_a]
                tile_b = self.grid_by_loc[loc_b]

                # Loop over wire pairs
                for pair in connection["wire_pairs"]:

                    # Wires in grid
                    wire_a = WireInGrid(tile_a, loc_a.x, loc_a.y, pair[0])
                    wire_b = WireInGrid(tile_b, loc_b.x, loc_b.y, pair[1])

                    # Connection
                    yield Connection(wire_a, wire_b)

        # Now yield all other connections
        return Connections.get_connections(self)
